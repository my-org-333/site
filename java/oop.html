<!doctype html>
<html lang="en">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">

    <title>Java Blog</title>
</head>

<body>

    <nav class="navbar sticky-top navbar-expand-lg navbar-light bg-light">
        <div class="container-fluid">
            <a class="navbar-brand" href="../index.html">Oleg Kucherenko</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavAltMarkup"
                aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNavAltMarkup">
                <div class="navbar-nav">
                    <a class="nav-link ms-4" href="../index.html">About</a>
                    <a class="nav-link ms-4 active" aria-current="page" href="./java_articles.html">Java Blog</a>
                    <a class="nav-link ms-4" href="../english/english_articles.html">Business English</a>
                </div>
            </div>
        </div>
    </nav>

    <div class="container mb-5 mt-5">
        <div class="mx-auto" style="width: 85%;">
            <h3 id="top">OOP</h3>
            <p>
                <a href="#polymorphism">Polymorphism</a> | <a href="#encapsulation">Encapsulation</a>
            </p>

            <h4 class="my-5">Inheritance</h4>
            <p>
                <b>Multiple Inheritance:</b> Java allows multiple inheritance only for interfaces. Classes, abstract
                classes are not available for multiple inheritance. Enums cannot be inherited at all.

                Can interfaces default methods cause a diamond problem? No, because in this case the compiler produces
                an error. Correct way is to override the default interface method with an explicit call of the needed
                implementation of the interface default method.

            <pre><code>
interface A {
    default void doSomething() {
        System.out.println("Default implementation from interface A");
    }
}

interface B {
    default void doSomething() {
        System.out.println("Default implementation from interface B");
    }
}

class MyClass implements InterfaceA, InterfaceB {
    public static void main(String[] argos) {
        new MyClass().doSomething(); // Compile error
    }
}


class MyClass implements InterfaceA, InterfaceB {
    public static void main(String[] argos) {
        new MyClass().doSomething(); // Ok
}

    @Override
    public void doSomething() {
        A.super.doSomething(); // Explicit call
    }

}
                </code></pre>

            <b>Final Keyword:</b> <code>final</code> keyword prevents class inheritance, or method overriding.
            <code>final</code> keyword is not allowed for Interfaces.
            </p>

            <h4 class="my-5" id="polymorphism">Polymorphism</h4>
            <p>
                <b>Overloading:</b> Overloaded method has the same name, same return type (not its subtype), but
                differs
                in argumentsâ€™ number, type, or order. Access and final modifiers are not counted to distinguish two
                methods.
                Static methods can be overloaded.
                <br><br>
                <b>Overriding:</b> Overridden method has the same name, same return type or its subtype, same
                arguments,
                same or less strict access modifier.
                Static methods cannot be annotated with @Override. But can be reimplemented within the subclass.
                <br><br>
                Both overloaded and overridden methods allow passing (not defining) subtype arguments.
                <br><br>

                <b>Static Polymorphism (compile-time):</b>
                Static polymorphism is achieved through method overloading in Java. Method overloading allows
                multiple
                methods with the same name but different parameter lists to coexist in the same class.
                The compiler determines which method to invoke based on the number, type, and order of the arguments
                passed to the method. The decision of which method to call is made at compile-time, based on the
                static
                types of the arguments.
                <br><br>
                <b>Dynamic Polymorphism (runtime):</b>
                Dynamic polymorphism is achieved through method overriding and inheritance in Java.
                Method overriding occurs when a subclass provides its implementation of a method that is already
                defined
                in its superclass. The subclass overrides the method with the same name, return type, and parameter
                list
                as the superclass.

                When a method is invoked on an object, the JVM determines which version of the method to execute
                based
                on the actual type of the object, not the reference type. The decision of which method to call is
                made
                at runtime, based on the dynamic type of the object.
            </p>

            <h4 class="my-5" id="encapsulation">Encapsulation</h4>
            <div>
                <p>Possibility to manage the level of access to the fields, methods, classes, interfaces, enumerations.
                </p>

                <table class="table table-bordered table-responsive">
                    <thead>
                        <tr>
                            <th></th>
                            <th>Private</th>
                            <th>No Modifier</th>
                            <th>Protected</th>
                            <th>Public</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Fields</td>
                            <td>Applicable</td>
                            <td>Applicable</td>
                            <td>Applicable</td>
                            <td>Applicable</td>
                        </tr>
                        <tr>
                            <td>Methods</td>
                            <td>Applicable</td>
                            <td>Applicable</td>
                            <td>Applicable</td>
                            <td>Applicable</td>
                        </tr>
                        <tr>
                            <td>Classes</td>
                            <td>Not Applicable</td>
                            <td>Applicable</td>
                            <td>Not Applicable</td>
                            <td>Applicable</td>
                        </tr>
                        <tr>
                            <td>Interfaces</td>
                            <td>Not Applicable</td>
                            <td>Applicable</td>
                            <td>Not Applicable</td>
                            <td>Applicable</td>
                        </tr>
                        <tr>
                            <td>Enumerations</td>
                            <td>Not Applicable</td>
                            <td>Applicable</td>
                            <td>Not Applicable</td>
                            <td>Applicable</td>
                        </tr>
                    </tbody>
                </table>

                <p>
                    <br>
                    <b>Most strict to less strict</b>
                    <br><br>
                    <b>Private:</b> Fields and methods are visible and accessible from their class only. Not applicable
                    to
                    the classes, interfaces, enumerations.
                    <br><br>
                    <b>No modifier (package-private):</b> Fields, methods, classes, interfaces, enumerations are visible
                    and
                    accessible from their package only.
                    <br><br>
                    <b>Protected:</b> Fields and methods are visible and accessible (1) from their package, and (2) from
                    their subclasses from any package. Not applicable to the classes, interfaces, enumerations.
                    <br><br>
                    <b>Public:</b> Fields, methods, classes, interfaces, enumerations are visible and accessible from
                    any
                    package.
                </p>
            </div>

            <p>
                <a href="#top">Top</a>
            </p>

        </div>
    </div>

    <!-- Optional JavaScript; choose one of the two! -->

    <!-- Option 1: Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
        crossorigin="anonymous"></script>

    <!-- Option 2: Separate Popper and Bootstrap JS -->
    <!--
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js" integrity="sha384-IQsoLXl5PILFhosVNubq5LC7Qb9DXgDA9i+tQ8Zj3iwWAwPtgFTxbJ8NT4GN1R8p" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.min.js" integrity="sha384-cVKIPhGWiC2Al4u+LWgxfKTRIcfu0JTxR+EQDz/bgldoEyl4H0zUF0QKbrJ0EcQF" crossorigin="anonymous"></script>
    -->
</body>

</html>